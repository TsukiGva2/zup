ARG.Usage usage       = NEW("Usage: %0% [flags]")
ARG.String newproject = NEW("n", "new", NIL, "create a new project")
ARG.Bool run          = NEW("r", "run", FALSE, "compile and run a project")
ARG.String delete     = NEW("D", "delete", NIL, "delete a project's folder")
ARG.Int  maxdepth     = NEW("p", "depth", 2, "max number of directories to search for a makefile, defaults to 2")

PROC dieOnErr(status stat, string msg, bool fatal = TRUE)
  IF stat.Equal(FAIL)
    IF fatal
      LOG.fatal(msg)
    ELSE
      LOG.error(msg)
    }
  }
}

PROC delDir(string name)
  FOR file IN IO.dirList(name)
    file = name .. "/" .. file
    IF IO.isDirectory(file)
      delDir(file) # recursively delete directories
      #dieOnErr(IO.rmdir(file), "couldn't delete dir", FALSE)
    ELSE
      dieOnErr(IO.delete(file), "couldn't delete file " .. file, FALSE)
    }
  }
  dieOnErr(IO.rmdir(name), "error deleting dir")
}

PROC findMakefile(int depth, int curr = 0)
  IF !IO.isReadable("Makefile") # recursively descend into dirtree searching for a makefile
                                # yes, i really like recursion
    IF curr <= depth
      dieOnErr(IO.chdir(".."), "couldn't descend directory")
      findMakefile(depth, curr + 1)
    ELSE
      LOG.fatal(
          "no Makefile found in directory tree (up to " .. depth .. " directories behind)" ..
          ", if your makefile is even further, try running with --depth X")
    }
  }
}

FUNC Main() int
  IF newproject.get() != NIL
  
    string projectname = newproject.get()

    list<string> makefileText = [
        "ZU=zimbu",
        "ZUFLAGS=",
        "all:",
        "\t$(ZU) $(ZUFLAGS) src/main.zu -o bin/" .. projectname,
        ""]

    list<string> hwText = [
        "FUNC Main() int",
        "  IO.print(\"hello, world!\")",
        "  RETURN 0",
        "}",
        ""]

    list<string> gitignoreText = [
        "ZUDIR/",
        "bin/",
        "buildlog",
        ""]

    dieOnErr(IO.mkdir(projectname), "error creating project dir")
    dieOnErr(IO.chdir(projectname), "error entering project dir")

    IO.File gitignore = IO.fileWriter(".gitignore", TRUE) # truncate = true
    dieOnErr(gitignore.writeAllLines(gitignoreText), "error writing gitignore", FALSE)
    dieOnErr(gitignore.flush(), "error flushing .gitignore", FALSE)
    gitignore.close()

    dieOnErr(IO.mkdir("src"), "error creating source dir")
    dieOnErr(IO.chdir("src"), "error entering source dir")

    IO.File mainfile = IO.fileWriter("main.zu", TRUE)
    dieOnErr(mainfile.writeAllLines(hwText), "error writing main.zu", FALSE)
    dieOnErr(mainfile.flush(), "error flushing src/main.zu")
    mainfile.close()
    
    dieOnErr(IO.chdir(".."), "error leaving source dir")
    dieOnErr(IO.mkdir("bin"), "error creating bin dir")

    IO.File makefile = IO.fileWriter("Makefile", TRUE)
    dieOnErr(makefile.writeAllLines(makefileText), FALSE)
    dieOnErr(makefile.flush(), "error flushing Makefile")
    makefile.close()

  ELSEIF delete.get() != NIL
    
    string projectname = delete.get()
    
    IO.print("are you sure you want to delete " .. projectname .. "?\n")
    IF IO.readChar().asString().toLower() == "y"
      IF IO.isDirectory(projectname)
        delDir(projectname)
        IO.print("done")
      ELSE
        LOG.fatal(projectname .. " is not a directory")
      }
    ELSE
      IO.print("ok! be careful next time\n")
      RETURN 0
    }
  
  ELSEIF run.get()
    findMakefile(maxdepth.get())
    SYS.Process process = NEW("make")
      .writeTo("buildlog")
      .writeErrorsToOut(TRUE)
      .start()

    process.wait()
    IF process.didExitNormally()
      IF process.getExitValue() != 0
        LOG.fatal("couldn't compile program, check buildlog for more information")
      }
    ELSE
      LOG.fatal("process didn't exit normally, check buildlog for more information")
    }

    delDir("src/ZUDIR")

    SYS.shell("bin/" .. IO.tail(IO.getdir())) # XXX: the good ol' system()
  }

  RETURN 0
}
